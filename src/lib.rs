//! # jsonrpc-hyper
//!
//! An implementation of the jsonrpc::client::HttpRoundTripper for a Hyper client.

#![crate_type = "lib"]
#![crate_type = "rlib"]
#![crate_type = "dylib"]
#![crate_name = "jsonrpc_hyper"]
// Coding conventions
#![deny(non_upper_case_globals)]
#![deny(non_camel_case_types)]
#![deny(non_snake_case)]
#![deny(unused_mut)]
#![warn(missing_docs)]

extern crate http;
extern crate hyper;
extern crate jsonrpc;

use std::{error, fmt, io};

use hyper::rt::{Future, Stream};

/// Local error type.
#[derive(Debug)]
pub enum Error {
	/// Error generated by HTTP crate.
	Http(http::Error),
	/// Error generated by Hyper client.
	Hyper(hyper::error::Error),
	/// Error generated by stream handling with io package.
	Io(io::Error),
}

impl fmt::Display for Error {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		match *self {
			Error::Http(ref e) => write!(f, "HTTP error: {}", e),
			Error::Hyper(ref e) => write!(f, "Hyper error: {}", e),
			Error::Io(ref e) => write!(f, "I/O error: {}", e),
		}
	}
}

impl error::Error for Error {
	fn description(&self) -> &str {
		match *self {
			Error::Http(_) => "HTTP error",
			Error::Hyper(_) => "Hyper error",
			Error::Io(_) => "I/O error",
		}
	}

	fn cause(&self) -> Option<&error::Error> {
		match *self {
			Error::Http(ref e) => Some(e),
			Error::Hyper(ref e) => Some(e),
			Error::Io(ref e) => Some(e),
		}
	}
}

impl From<http::Error> for Error {
	fn from(e: http::Error) -> Error {
		Error::Http(e)
	}
}

impl From<hyper::error::Error> for Error {
	fn from(e: hyper::error::Error) -> Error {
		Error::Hyper(e)
	}
}

impl From<io::Error> for Error {
	fn from(e: io::Error) -> Error {
		Error::Io(e)
	}
}

/// An implementation of the jsonrpc::client::HttpRoundTripper for a Hyper client.
pub struct HyperRoundTripper(hyper::Client<hyper::client::HttpConnector, hyper::body::Body>);

impl HyperRoundTripper {
	/// Create a new HyperRoundTripper.
	pub fn new(
		client: hyper::Client<hyper::client::HttpConnector, hyper::body::Body>,
	) -> HyperRoundTripper {
		HyperRoundTripper(client)
	}
}

/// Wraps the hyper::Body type to provide the io::Read interface.
pub struct HyperBodyReader(hyper::Body);

impl io::Read for HyperBodyReader {
	fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
		let mut cnt = 0;
		loop {
			match self.0.poll().map_err(|e| io::Error::new(io::ErrorKind::Other, e))? {
				futures::Async::Ready(None) => break,
				futures::Async::Ready(Some(chunk)) => {
					cnt += io::Read::read(&mut &*chunk.into_bytes(), buf)?;
				}
				futures::Async::NotReady => {}
			}
		}
		Ok(cnt)
	}
}

impl jsonrpc::client::HttpRoundTripper for HyperRoundTripper {
	type ResponseBody = HyperBodyReader;
	type Err = Error;

	fn request(
		&self,
		request: http::Request<&[u8]>,
	) -> Result<http::Response<Self::ResponseBody>, Self::Err> {
		// Convert to a Hyper-compliant version of the request.
		let (req_parts, req_body) = request.into_parts();
		let hyper_request = http::Request::from_parts(req_parts, req_body.to_vec().into());

		// Make the call using the Hyper client.
		let (resp_parts, resp_body) = self.0.request(hyper_request).wait()?.into_parts();

		// Build the response using the io::Read wrapper.
		let body_reader = HyperBodyReader(resp_body.wait().into_inner());
		let response = http::Response::from_parts(resp_parts, body_reader);

		Ok(response)
	}
}

/// Create a new JSONRPC client using the given Hyper client.
pub fn new_with_client(
	client: hyper::Client<hyper::client::HttpConnector, hyper::body::Body>,
	url: String,
	user: Option<String>,
	pass: Option<String>,
) -> jsonrpc::client::Client<HyperRoundTripper> {
	jsonrpc::client::Client::new(HyperRoundTripper::new(client), url, user, pass)
}

/// Create a new JSONRPC client using a new Hyper client.
pub fn new(
	url: String,
	user: Option<String>,
	pass: Option<String>,
) -> jsonrpc::client::Client<HyperRoundTripper> {
	new_with_client(hyper::Client::new(), url, user, pass)
}
