//! # jsonrpc-hyper
//!
//! An implementation of the jsonrpc::client::HttpRoundTripper for a Hyper client.

#![crate_type = "lib"]
#![crate_type = "rlib"]
#![crate_type = "dylib"]
#![crate_name = "jsonrpc_hyper"]
// Coding conventions
#![deny(non_upper_case_globals)]
#![deny(non_camel_case_types)]
#![deny(non_snake_case)]
#![deny(unused_mut)]
#![warn(missing_docs)]

extern crate http;
extern crate hyper;
extern crate jsonrpc;

use std::{error, fmt};

/// Local error type.
#[derive(Debug)]
pub enum Error {
	/// Error generated by HTTP crate.
	Http(http::Error),
	/// Error generated by Hyper client.
	Hyper(hyper::error::Error),
}

impl fmt::Display for Error {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		match *self {
			Error::Http(ref e) => write!(f, "HTTP error: {}", e),
			Error::Hyper(ref e) => write!(f, "Hyper error: {}", e),
		}
	}
}

impl error::Error for Error {
	fn description(&self) -> &str {
		match *self {
			Error::Http(_) => "HTTP error",
			Error::Hyper(_) => "Hyper error",
		}
	}

	fn cause(&self) -> Option<&error::Error> {
		match *self {
			Error::Http(ref e) => Some(e),
			Error::Hyper(ref e) => Some(e),
		}
	}
}

impl From<http::Error> for Error {
	fn from(e: http::Error) -> Error {
		Error::Http(e)
	}
}

impl From<hyper::error::Error> for Error {
	fn from(e: hyper::error::Error) -> Error {
		Error::Hyper(e)
	}
}

/// An implementation of the jsonrpc::client::HttpRoundTripper for a Hyper client.
pub struct HyperRoundTripper(hyper::Client);

impl HyperRoundTripper {
	/// Create a new HyperRoundTripper.
	pub fn new(client: hyper::Client) -> HyperRoundTripper {
		HyperRoundTripper(client)
	}
}

impl jsonrpc::client::HttpRoundTripper for HyperRoundTripper {
	type ResponseBody = hyper::client::Response;
	type Err = Error;

	fn request(
		&self,
		request: http::Request<&[u8]>,
	) -> Result<http::Response<Self::ResponseBody>, Self::Err> {
		assert!(request.method() == http::method::Method::POST);

		// Copy the headers from the HTTP request into Hyper headers.
		let mut hyper_headers = hyper::header::Headers::new();
		for (key, value) in request.headers().clone() {
			if key.is_none() {
				continue;
			}
			hyper_headers.append_raw(key.unwrap().as_str().to_owned(), value.as_bytes().to_vec());
		}

		let response = self
			.0
			.post(&request.uri().to_string())
			.headers(hyper_headers)
			.body(*request.body())
			.send()?;

		let mut response_builder = http::response::Response::builder();
		response_builder
			.status(http::status::StatusCode::from_u16(response.status.to_u16()).unwrap());

		// Add the response headers.
		for header in response.headers.iter() {
			response_builder.header(header.name(), header.value_string());
		}

		Ok(response_builder.body(response).unwrap())
	}
}

/// Create a new JSONRPC client using the given Hyper client.
pub fn new_with_client(
	client: hyper::Client,
	url: String,
	user: Option<String>,
	pass: Option<String>,
) -> jsonrpc::client::Client<HyperRoundTripper> {
	jsonrpc::client::Client::new(HyperRoundTripper::new(client), url, user, pass)
}

/// Create a new JSONRPC client using a new Hyper client.
pub fn new(
	url: String,
	user: Option<String>,
	pass: Option<String>,
) -> jsonrpc::client::Client<HyperRoundTripper> {
	new_with_client(hyper::Client::new(), url, user, pass)
}
